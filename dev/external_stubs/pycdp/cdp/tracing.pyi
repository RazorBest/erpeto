import enum
import typing
from . import io as io
from .util import T_JSON_DICT as T_JSON_DICT, event_class as event_class
from dataclasses import dataclass

class MemoryDumpConfig(dict):
    def to_json(self) -> dict: ...
    @classmethod
    def from_json(cls, json: dict) -> MemoryDumpConfig: ...

@dataclass
class TraceConfig:
    record_mode: typing.Optional[str] = ...
    trace_buffer_size_in_kb: typing.Optional[float] = ...
    enable_sampling: typing.Optional[bool] = ...
    enable_systrace: typing.Optional[bool] = ...
    enable_argument_filter: typing.Optional[bool] = ...
    included_categories: typing.Optional[typing.List[str]] = ...
    excluded_categories: typing.Optional[typing.List[str]] = ...
    synthetic_delays: typing.Optional[typing.List[str]] = ...
    memory_dump_config: typing.Optional[MemoryDumpConfig] = ...
    def to_json(self) -> T_JSON_DICT: ...
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> TraceConfig: ...
    def __init__(self, record_mode, trace_buffer_size_in_kb, enable_sampling, enable_systrace, enable_argument_filter, included_categories, excluded_categories, synthetic_delays, memory_dump_config) -> None: ...

class StreamFormat(enum.Enum):
    JSON: str
    PROTO: str
    def to_json(self) -> str: ...
    @classmethod
    def from_json(cls, json: str) -> StreamFormat: ...

class StreamCompression(enum.Enum):
    NONE: str
    GZIP: str
    def to_json(self) -> str: ...
    @classmethod
    def from_json(cls, json: str) -> StreamCompression: ...

class MemoryDumpLevelOfDetail(enum.Enum):
    BACKGROUND: str
    LIGHT: str
    DETAILED: str
    def to_json(self) -> str: ...
    @classmethod
    def from_json(cls, json: str) -> MemoryDumpLevelOfDetail: ...

class TracingBackend(enum.Enum):
    AUTO: str
    CHROME: str
    SYSTEM: str
    def to_json(self) -> str: ...
    @classmethod
    def from_json(cls, json: str) -> TracingBackend: ...

def end() -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def get_categories() -> typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.List[str]]: ...
def record_clock_sync_marker(sync_id: str) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def request_memory_dump(deterministic: typing.Optional[bool] = None, level_of_detail: typing.Optional[MemoryDumpLevelOfDetail] = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.Tuple[str, bool]]: ...
def start(categories: typing.Optional[str] = None, options: typing.Optional[str] = None, buffer_usage_reporting_interval: typing.Optional[float] = None, transfer_mode: typing.Optional[str] = None, stream_format: typing.Optional[StreamFormat] = None, stream_compression: typing.Optional[StreamCompression] = None, trace_config: typing.Optional[TraceConfig] = None, perfetto_config: typing.Optional[str] = None, tracing_backend: typing.Optional[TracingBackend] = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...

@dataclass
class BufferUsage:
    percent_full: typing.Optional[float]
    event_count: typing.Optional[float]
    value: typing.Optional[float]
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> BufferUsage: ...
    def to_json(self) -> T_JSON_DICT: ...
    def __init__(self, percent_full, event_count, value) -> None: ...

@dataclass
class DataCollected:
    value: typing.List[dict]
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DataCollected: ...
    def to_json(self) -> T_JSON_DICT: ...
    def __init__(self, value) -> None: ...

@dataclass
class TracingComplete:
    data_loss_occurred: bool
    stream: typing.Optional[io.StreamHandle]
    trace_format: typing.Optional[StreamFormat]
    stream_compression: typing.Optional[StreamCompression]
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> TracingComplete: ...
    def to_json(self) -> T_JSON_DICT: ...
    def __init__(self, data_loss_occurred, stream, trace_format, stream_compression) -> None: ...
