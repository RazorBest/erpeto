import enum
import typing
from . import runtime as runtime
from .util import T_JSON_DICT as T_JSON_DICT, event_class as event_class
from dataclasses import dataclass

class BreakpointId(str):
    def to_json(self) -> str: ...
    @classmethod
    def from_json(cls, json: str) -> BreakpointId: ...

class CallFrameId(str):
    def to_json(self) -> str: ...
    @classmethod
    def from_json(cls, json: str) -> CallFrameId: ...

@dataclass
class Location:
    script_id: runtime.ScriptId
    line_number: int
    column_number: int | None = ...
    def to_json(self) -> T_JSON_DICT: ...
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Location: ...

@dataclass
class ScriptPosition:
    line_number: int
    column_number: int
    def to_json(self) -> T_JSON_DICT: ...
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ScriptPosition: ...

@dataclass
class LocationRange:
    script_id: runtime.ScriptId
    start: ScriptPosition
    end: ScriptPosition
    def to_json(self) -> T_JSON_DICT: ...
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> LocationRange: ...

@dataclass
class CallFrame:
    call_frame_id: CallFrameId
    function_name: str
    location: Location
    url: str
    scope_chain: list[Scope]
    this: runtime.RemoteObject
    function_location: Location | None = ...
    return_value: runtime.RemoteObject | None = ...
    can_be_restarted: bool | None = ...
    def to_json(self) -> T_JSON_DICT: ...
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CallFrame: ...

@dataclass
class Scope:
    type_: str
    object_: runtime.RemoteObject
    name: str | None = ...
    start_location: Location | None = ...
    end_location: Location | None = ...
    def to_json(self) -> T_JSON_DICT: ...
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Scope: ...

@dataclass
class SearchMatch:
    line_number: float
    line_content: str
    def to_json(self) -> T_JSON_DICT: ...
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> SearchMatch: ...

@dataclass
class BreakLocation:
    script_id: runtime.ScriptId
    line_number: int
    column_number: int | None = ...
    type_: str | None = ...
    def to_json(self) -> T_JSON_DICT: ...
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> BreakLocation: ...

@dataclass
class WasmDisassemblyChunk:
    lines: list[str]
    bytecode_offsets: list[int]
    def to_json(self) -> T_JSON_DICT: ...
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> WasmDisassemblyChunk: ...

class ScriptLanguage(enum.Enum):
    JAVA_SCRIPT = 'JavaScript'
    WEB_ASSEMBLY = 'WebAssembly'
    def to_json(self) -> str: ...
    @classmethod
    def from_json(cls, json: str) -> ScriptLanguage: ...

@dataclass
class DebugSymbols:
    type_: str
    external_url: str | None = ...
    def to_json(self) -> T_JSON_DICT: ...
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DebugSymbols: ...

@dataclass
class ResolvedBreakpoint:
    breakpoint_id: BreakpointId
    location: Location
    def to_json(self) -> T_JSON_DICT: ...
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ResolvedBreakpoint: ...

def continue_to_location(location: Location, target_call_frames: str | None = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def disable() -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def enable(max_scripts_cache_size: float | None = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]: ...
def evaluate_on_call_frame(call_frame_id: CallFrameId, expression: str, object_group: str | None = None, include_command_line_api: bool | None = None, silent: bool | None = None, return_by_value: bool | None = None, generate_preview: bool | None = None, throw_on_side_effect: bool | None = None, timeout: runtime.TimeDelta | None = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, tuple[runtime.RemoteObject, runtime.ExceptionDetails | None]]: ...
def get_possible_breakpoints(start: Location, end: Location | None = None, restrict_to_function: bool | None = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, list[BreakLocation]]: ...
def get_script_source(script_id: runtime.ScriptId) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, tuple[str, str | None]]: ...
def disassemble_wasm_module(script_id: runtime.ScriptId) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, tuple[str | None, int, list[int], WasmDisassemblyChunk]]: ...
def next_wasm_disassembly_chunk(stream_id: str) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]: ...
def get_wasm_bytecode(script_id: runtime.ScriptId) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, str]: ...
def get_stack_trace(stack_trace_id: runtime.StackTraceId) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]: ...
def pause() -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def pause_on_async_call(parent_stack_trace_id: runtime.StackTraceId) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def remove_breakpoint(breakpoint_id: BreakpointId) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def restart_frame(call_frame_id: CallFrameId, mode: str | None = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame], runtime.StackTrace | None, runtime.StackTraceId | None]]: ...
def resume(terminate_on_resume: bool | None = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def search_in_content(script_id: runtime.ScriptId, query: str, case_sensitive: bool | None = None, is_regex: bool | None = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, list[SearchMatch]]: ...
def set_async_call_stack_depth(max_depth: int) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def set_blackbox_execution_contexts(unique_ids: list[str]) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def set_blackbox_patterns(patterns: list[str], skip_anonymous: bool | None = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def set_blackboxed_ranges(script_id: runtime.ScriptId, positions: list[ScriptPosition]) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def set_breakpoint(location: Location, condition: str | None = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, Location]]: ...
def set_instrumentation_breakpoint(instrumentation: str) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]: ...
def set_breakpoint_by_url(line_number: int, url: str | None = None, url_regex: str | None = None, script_hash: str | None = None, column_number: int | None = None, condition: str | None = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, tuple[BreakpointId, list[Location]]]: ...
def set_breakpoint_on_function_call(object_id: runtime.RemoteObjectId, condition: str | None = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]: ...
def set_breakpoints_active(active: bool) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def set_pause_on_exceptions(state: str) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def set_return_value(new_value: runtime.CallArgument) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def set_script_source(script_id: runtime.ScriptId, script_source: str, dry_run: bool | None = None, allow_top_frame_editing: bool | None = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, tuple[list[CallFrame] | None, bool | None, runtime.StackTrace | None, runtime.StackTraceId | None, str, runtime.ExceptionDetails | None]]: ...
def set_skip_all_pauses(skip: bool) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def set_variable_value(scope_number: int, variable_name: str, new_value: runtime.CallArgument, call_frame_id: CallFrameId) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def step_into(break_on_async_call: bool | None = None, skip_list: list[LocationRange] | None = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def step_out() -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def step_over(skip_list: list[LocationRange] | None = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...

@dataclass
class BreakpointResolved:
    breakpoint_id: BreakpointId
    location: Location
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> BreakpointResolved: ...

@dataclass
class Paused:
    call_frames: list[CallFrame]
    reason: str
    data: dict | None
    hit_breakpoints: list[str] | None
    async_stack_trace: runtime.StackTrace | None
    async_stack_trace_id: runtime.StackTraceId | None
    async_call_stack_trace_id: runtime.StackTraceId | None
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Paused: ...

@dataclass
class Resumed:
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Resumed: ...

@dataclass
class ScriptFailedToParse:
    script_id: runtime.ScriptId
    url: str
    start_line: int
    start_column: int
    end_line: int
    end_column: int
    execution_context_id: runtime.ExecutionContextId
    hash_: str
    build_id: str
    execution_context_aux_data: dict | None
    source_map_url: str | None
    has_source_url: bool | None
    is_module: bool | None
    length: int | None
    stack_trace: runtime.StackTrace | None
    code_offset: int | None
    script_language: ScriptLanguage | None
    embedder_name: str | None
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ScriptFailedToParse: ...

@dataclass
class ScriptParsed:
    script_id: runtime.ScriptId
    url: str
    start_line: int
    start_column: int
    end_line: int
    end_column: int
    execution_context_id: runtime.ExecutionContextId
    hash_: str
    build_id: str
    execution_context_aux_data: dict | None
    is_live_edit: bool | None
    source_map_url: str | None
    has_source_url: bool | None
    is_module: bool | None
    length: int | None
    stack_trace: runtime.StackTrace | None
    code_offset: int | None
    script_language: ScriptLanguage | None
    debug_symbols: list[DebugSymbols] | None
    embedder_name: str | None
    resolved_breakpoints: list[ResolvedBreakpoint] | None
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ScriptParsed: ...
