from _typeshed import Incomplete
from dataclasses import dataclass
from enum import Enum

log_level: Incomplete
logger: Incomplete
GENERATED_PACKAGE_NOTICE: str
SHARED_HEADER: str
INIT_HEADER: Incomplete
MODULE_HEADER: Incomplete
current_version: str
BACKTICK_RE: Incomplete

def indent(s: str, n: int): ...
def escape_backticks(docstr: str) -> str: ...
def inline_doc(description) -> str: ...
def docstring(description: str | None) -> str: ...
def is_builtin(name: str) -> bool: ...
def snake_case(name: str) -> str: ...
def ref_to_python(ref: str) -> str: ...
def ref_to_python_domain(ref: str, domain: str) -> str: ...

class CdpPrimitiveType(Enum):
    boolean = 'bool'
    integer = 'int'
    number = 'float'
    object = 'dict'
    string = 'str'
    @classmethod
    def get_annotation(cls, cdp_type): ...
    @classmethod
    def get_constructor(cls, cdp_type, val): ...

@dataclass
class CdpItems:
    type: str
    ref: str
    @classmethod
    def from_json(cls, type) -> CdpItems: ...

@dataclass
class CdpProperty:
    name: str
    description: str | None
    type: str | None
    ref: str | None
    enum: list[str]
    items: CdpItems | None
    optional: bool
    experimental: bool
    deprecated: bool
    domain: str
    @property
    def py_name(self) -> str: ...
    @property
    def py_annotation(self) -> str: ...
    @classmethod
    def from_json(cls, prop, domain: str) -> CdpProperty: ...
    def generate_decl(self) -> str: ...
    def generate_to_json(self, dict_: str, use_self: bool = True) -> str: ...
    def generate_from_json(self, dict_) -> str: ...

@dataclass
class CdpType:
    id: str
    description: str | None
    type: str
    items: CdpItems | None
    enum: list[str]
    properties: list[CdpProperty]
    @classmethod
    def from_json(cls, type_, domain: str) -> CdpType: ...
    def generate_code(self) -> str: ...
    def generate_primitive_code(self) -> str: ...
    def generate_enum_code(self) -> str: ...
    def generate_class_code(self) -> str: ...
    def get_refs(self): ...

class CdpParameter(CdpProperty):
    def generate_code(self) -> str: ...
    def generate_decl(self) -> str: ...
    def generate_doc(self) -> str: ...
    def generate_from_json(self, dict_) -> str: ...

class CdpReturn(CdpProperty):
    @property
    def py_annotation(self): ...
    def generate_doc(self): ...
    def generate_return(self, dict_): ...

@dataclass
class CdpCommand:
    name: str
    description: str
    experimental: bool
    deprecated: bool
    parameters: list[CdpParameter]
    returns: list[CdpReturn]
    domain: str
    @property
    def py_name(self): ...
    @classmethod
    def from_json(cls, command, domain) -> CdpCommand: ...
    def generate_code(self) -> str: ...
    def get_refs(self): ...

@dataclass
class CdpEvent:
    name: str
    description: str | None
    deprecated: bool
    experimental: bool
    parameters: list[CdpParameter]
    domain: str
    @property
    def py_name(self): ...
    @classmethod
    def from_json(cls, json: dict, domain: str): ...
    def generate_code(self) -> str: ...
    def get_refs(self): ...

@dataclass
class CdpDomain:
    domain: str
    description: str | None
    experimental: bool
    dependencies: list[str]
    types: list[CdpType]
    commands: list[CdpCommand]
    events: list[CdpEvent]
    @property
    def module(self): ...
    @classmethod
    def from_json(cls, domain: dict): ...
    def generate_code(self) -> str: ...
    def generate_imports(self): ...
    def generate_sphinx(self) -> str: ...

def parse(json_path, output_path): ...
def generate_init(init_path, domains) -> None: ...
def generate_docs(docs_path, domains) -> None: ...
def fix_protocol_spec(domains) -> None: ...
def selfgen() -> None: ...
def cdpgen(): ...
