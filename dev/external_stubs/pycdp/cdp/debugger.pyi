import enum
import typing
from . import runtime as runtime
from .util import T_JSON_DICT as T_JSON_DICT, event_class as event_class
from dataclasses import dataclass

class BreakpointId(str):
    def to_json(self) -> str: ...
    @classmethod
    def from_json(cls, json: str) -> BreakpointId: ...

class CallFrameId(str):
    def to_json(self) -> str: ...
    @classmethod
    def from_json(cls, json: str) -> CallFrameId: ...

@dataclass
class Location:
    script_id: runtime.ScriptId
    line_number: int
    column_number: typing.Optional[int] = ...
    def to_json(self) -> T_JSON_DICT: ...
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Location: ...
    def __init__(self, script_id, line_number, column_number) -> None: ...

@dataclass
class ScriptPosition:
    line_number: int
    column_number: int
    def to_json(self) -> T_JSON_DICT: ...
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ScriptPosition: ...
    def __init__(self, line_number, column_number) -> None: ...

@dataclass
class LocationRange:
    script_id: runtime.ScriptId
    start: ScriptPosition
    end: ScriptPosition
    def to_json(self) -> T_JSON_DICT: ...
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> LocationRange: ...
    def __init__(self, script_id, start, end) -> None: ...

@dataclass
class CallFrame:
    call_frame_id: CallFrameId
    function_name: str
    location: Location
    url: str
    scope_chain: typing.List[Scope]
    this: runtime.RemoteObject
    function_location: typing.Optional[Location] = ...
    return_value: typing.Optional[runtime.RemoteObject] = ...
    can_be_restarted: typing.Optional[bool] = ...
    def to_json(self) -> T_JSON_DICT: ...
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> CallFrame: ...
    def __init__(self, call_frame_id, function_name, location, url, scope_chain, this, function_location, return_value, can_be_restarted) -> None: ...

@dataclass
class Scope:
    type_: str
    object_: runtime.RemoteObject
    name: typing.Optional[str] = ...
    start_location: typing.Optional[Location] = ...
    end_location: typing.Optional[Location] = ...
    def to_json(self) -> T_JSON_DICT: ...
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Scope: ...
    def __init__(self, type_, object_, name, start_location, end_location) -> None: ...

@dataclass
class SearchMatch:
    line_number: float
    line_content: str
    def to_json(self) -> T_JSON_DICT: ...
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> SearchMatch: ...
    def __init__(self, line_number, line_content) -> None: ...

@dataclass
class BreakLocation:
    script_id: runtime.ScriptId
    line_number: int
    column_number: typing.Optional[int] = ...
    type_: typing.Optional[str] = ...
    def to_json(self) -> T_JSON_DICT: ...
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> BreakLocation: ...
    def __init__(self, script_id, line_number, column_number, type_) -> None: ...

@dataclass
class WasmDisassemblyChunk:
    lines: typing.List[str]
    bytecode_offsets: typing.List[int]
    def to_json(self) -> T_JSON_DICT: ...
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> WasmDisassemblyChunk: ...
    def __init__(self, lines, bytecode_offsets) -> None: ...

class ScriptLanguage(enum.Enum):
    JAVA_SCRIPT: str
    WEB_ASSEMBLY: str
    def to_json(self) -> str: ...
    @classmethod
    def from_json(cls, json: str) -> ScriptLanguage: ...

@dataclass
class DebugSymbols:
    type_: str
    external_url: typing.Optional[str] = ...
    def to_json(self) -> T_JSON_DICT: ...
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> DebugSymbols: ...
    def __init__(self, type_, external_url) -> None: ...

def continue_to_location(location: Location, target_call_frames: typing.Optional[str] = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def disable() -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def enable(max_scripts_cache_size: typing.Optional[float] = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, runtime.UniqueDebuggerId]: ...
def evaluate_on_call_frame(call_frame_id: CallFrameId, expression: str, object_group: typing.Optional[str] = None, include_command_line_api: typing.Optional[bool] = None, silent: typing.Optional[bool] = None, return_by_value: typing.Optional[bool] = None, generate_preview: typing.Optional[bool] = None, throw_on_side_effect: typing.Optional[bool] = None, timeout: typing.Optional[runtime.TimeDelta] = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.Tuple[runtime.RemoteObject, typing.Optional[runtime.ExceptionDetails]]]: ...
def get_possible_breakpoints(start: Location, end: typing.Optional[Location] = None, restrict_to_function: typing.Optional[bool] = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.List[BreakLocation]]: ...
def get_script_source(script_id: runtime.ScriptId) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.Tuple[str, typing.Optional[str]]]: ...
def disassemble_wasm_module(script_id: runtime.ScriptId) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.Tuple[typing.Optional[str], int, typing.List[int], WasmDisassemblyChunk]]: ...
def next_wasm_disassembly_chunk(stream_id: str) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, WasmDisassemblyChunk]: ...
def get_wasm_bytecode(script_id: runtime.ScriptId) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, str]: ...
def get_stack_trace(stack_trace_id: runtime.StackTraceId) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, runtime.StackTrace]: ...
def pause() -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def pause_on_async_call(parent_stack_trace_id: runtime.StackTraceId) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def remove_breakpoint(breakpoint_id: BreakpointId) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def restart_frame(call_frame_id: CallFrameId, mode: typing.Optional[str] = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.Tuple[typing.List[CallFrame], typing.Optional[runtime.StackTrace], typing.Optional[runtime.StackTraceId]]]: ...
def resume(terminate_on_resume: typing.Optional[bool] = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def search_in_content(script_id: runtime.ScriptId, query: str, case_sensitive: typing.Optional[bool] = None, is_regex: typing.Optional[bool] = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.List[SearchMatch]]: ...
def set_async_call_stack_depth(max_depth: int) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def set_blackbox_patterns(patterns: typing.List[str]) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def set_blackboxed_ranges(script_id: runtime.ScriptId, positions: typing.List[ScriptPosition]) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def set_breakpoint(location: Location, condition: typing.Optional[str] = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.Tuple[BreakpointId, Location]]: ...
def set_instrumentation_breakpoint(instrumentation: str) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]: ...
def set_breakpoint_by_url(line_number: int, url: typing.Optional[str] = None, url_regex: typing.Optional[str] = None, script_hash: typing.Optional[str] = None, column_number: typing.Optional[int] = None, condition: typing.Optional[str] = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.Tuple[BreakpointId, typing.List[Location]]]: ...
def set_breakpoint_on_function_call(object_id: runtime.RemoteObjectId, condition: typing.Optional[str] = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, BreakpointId]: ...
def set_breakpoints_active(active: bool) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def set_pause_on_exceptions(state: str) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def set_return_value(new_value: runtime.CallArgument) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def set_script_source(script_id: runtime.ScriptId, script_source: str, dry_run: typing.Optional[bool] = None, allow_top_frame_editing: typing.Optional[bool] = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, typing.Tuple[typing.Optional[typing.List[CallFrame]], typing.Optional[bool], typing.Optional[runtime.StackTrace], typing.Optional[runtime.StackTraceId], str, typing.Optional[runtime.ExceptionDetails]]]: ...
def set_skip_all_pauses(skip: bool) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def set_variable_value(scope_number: int, variable_name: str, new_value: runtime.CallArgument, call_frame_id: CallFrameId) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def step_into(break_on_async_call: typing.Optional[bool] = None, skip_list: typing.Optional[typing.List[LocationRange]] = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def step_out() -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...
def step_over(skip_list: typing.Optional[typing.List[LocationRange]] = None) -> typing.Generator[T_JSON_DICT, T_JSON_DICT, None]: ...

@dataclass
class BreakpointResolved:
    breakpoint_id: BreakpointId
    location: Location
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> BreakpointResolved: ...
    def to_json(self) -> T_JSON_DICT: ...
    def __init__(self, breakpoint_id, location) -> None: ...

@dataclass
class Paused:
    call_frames: typing.List[CallFrame]
    reason: str
    data: typing.Optional[dict]
    hit_breakpoints: typing.Optional[typing.List[str]]
    async_stack_trace: typing.Optional[runtime.StackTrace]
    async_stack_trace_id: typing.Optional[runtime.StackTraceId]
    async_call_stack_trace_id: typing.Optional[runtime.StackTraceId]
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Paused: ...
    def to_json(self) -> T_JSON_DICT: ...
    def __init__(self, call_frames, reason, data, hit_breakpoints, async_stack_trace, async_stack_trace_id, async_call_stack_trace_id) -> None: ...

@dataclass
class Resumed:
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> Resumed: ...
    def to_json(self) -> T_JSON_DICT: ...

@dataclass
class ScriptFailedToParse:
    script_id: runtime.ScriptId
    url: str
    start_line: int
    start_column: int
    end_line: int
    end_column: int
    execution_context_id: runtime.ExecutionContextId
    hash_: str
    execution_context_aux_data: typing.Optional[dict]
    source_map_url: typing.Optional[str]
    has_source_url: typing.Optional[bool]
    is_module: typing.Optional[bool]
    length: typing.Optional[int]
    stack_trace: typing.Optional[runtime.StackTrace]
    code_offset: typing.Optional[int]
    script_language: typing.Optional[ScriptLanguage]
    embedder_name: typing.Optional[str]
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ScriptFailedToParse: ...
    def to_json(self) -> T_JSON_DICT: ...
    def __init__(self, script_id, url, start_line, start_column, end_line, end_column, execution_context_id, hash_, execution_context_aux_data, source_map_url, has_source_url, is_module, length, stack_trace, code_offset, script_language, embedder_name) -> None: ...

@dataclass
class ScriptParsed:
    script_id: runtime.ScriptId
    url: str
    start_line: int
    start_column: int
    end_line: int
    end_column: int
    execution_context_id: runtime.ExecutionContextId
    hash_: str
    execution_context_aux_data: typing.Optional[dict]
    is_live_edit: typing.Optional[bool]
    source_map_url: typing.Optional[str]
    has_source_url: typing.Optional[bool]
    is_module: typing.Optional[bool]
    length: typing.Optional[int]
    stack_trace: typing.Optional[runtime.StackTrace]
    code_offset: typing.Optional[int]
    script_language: typing.Optional[ScriptLanguage]
    debug_symbols: typing.Optional[DebugSymbols]
    embedder_name: typing.Optional[str]
    @classmethod
    def from_json(cls, json: T_JSON_DICT) -> ScriptParsed: ...
    def to_json(self) -> T_JSON_DICT: ...
    def __init__(self, script_id, url, start_line, start_column, end_line, end_column, execution_context_id, hash_, execution_context_aux_data, is_live_edit, source_map_url, has_source_url, is_module, length, stack_trace, code_offset, script_language, debug_symbols, embedder_name) -> None: ...
